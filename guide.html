<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vara.eth Quickstart Developer Guide</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Geist:wght@400;500;600;800&family=JetBrains+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-primary: #fbfdff;
        --bg-secondary: #f4f7f9;
        --bg-code: #f0f4f8;
        --text-primary: #2d3748;
        --text-secondary: #5c696e;
        --text-muted: #8a9ba8;
        --accent-primary: #00ffc4;
        --accent-dark: #00d4a4;
        --accent-secondary: #16b768;
        --border-color: #e2e8f0;
        --code-keyword: #8b5cf6;
        --code-string: #059669;
        --code-function: #2563eb;
        --code-number: #dc2626;
        --code-comment: #94a3b8;
        --code-property: #0891b2;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Geist', -apple-system, BlinkMacSystemFont, sans-serif;
        background: var(--bg-primary);
        color: var(--text-secondary);
        line-height: 1.7;
        font-size: 15px;
        font-weight: 400;
        max-width: 820px;
        margin: 0 auto;
        padding: 60px 32px 80px;
        text-align: justify;
        word-break: break-word;
      }

      .hero {
        text-align: center;
        margin-bottom: 56px;
        padding-bottom: 48px;
        border-bottom: 1px solid var(--border-color);
      }

      .hero h1 {
        font-size: 36px;
        font-weight: 800;
        line-height: 1.2;
        margin-bottom: 16px;
        color: var(--text-primary);
      }

      .hero h1 span {
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .hero .subtitle {
        font-size: 16px;
        color: var(--text-secondary);
        max-width: 560px;
        margin: 0 auto;
      }

      section {
        margin-bottom: 48px;
      }

      h2 {
        font-size: 24px;
        font-weight: 700;
        margin-bottom: 20px;
        padding-bottom: 12px;
        border-bottom: 2px solid var(--accent-primary);
        color: var(--text-primary);
        display: inline-block;
      }

      h3 {
        font-size: 18px;
        font-weight: 600;
        margin: 32px 0 12px;
        color: var(--text-primary);
      }

      h4 {
        font-size: 15px;
        font-weight: 600;
        margin: 24px 0 8px;
        color: var(--text-primary);
      }

      p {
        margin-bottom: 14px;
      }

      strong {
        color: var(--text-primary);
        font-weight: 600;
      }

      a {
        color: var(--accent-dark);
        text-decoration: none;
        border-bottom: 1px solid transparent;
        transition: border-color 0.2s;
      }

      a:hover {
        border-bottom-color: var(--accent-dark);
      }

      ul,
      ol {
        margin: 14px 0;
        padding-left: 24px;
      }

      li {
        margin-bottom: 6px;
      }

      pre {
        background: var(--bg-code);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 20px;
        overflow-x: auto;
        margin: 20px 0;
        position: relative;
      }

      pre::before {
        content: attr(data-lang);
        position: absolute;
        top: 8px;
        right: 12px;
        font-size: 10px;
        font-family: 'JetBrains Mono', monospace;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      code {
        font-family: 'JetBrains Mono', monospace;
        font-size: 13px;
        line-height: 1.6;
      }

      pre code {
        color: var(--text-primary);
      }

      p code,
      li code {
        background: var(--bg-secondary);
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 13px;
        color: var(--code-function);
      }

      .keyword {
        color: var(--code-keyword);
      }
      .string {
        color: var(--code-string);
      }
      .function {
        color: var(--code-function);
      }
      .number {
        color: var(--code-number);
      }
      .comment {
        color: var(--code-comment);
        font-style: italic;
      }
      .type {
        color: var(--code-keyword);
      }
      .property {
        color: var(--code-property);
      }

      .callout {
        padding: 16px 20px;
        border-radius: 8px;
        margin: 20px 0;
        border-left: 3px solid;
        background: var(--bg-secondary);
      }

      .callout-info {
        border-color: #3b82f6;
      }
      .callout-warning {
        border-color: #f59e0b;
      }
      .callout-success {
        border-color: var(--accent-dark);
      }

      .callout-title {
        font-weight: 600;
        margin-bottom: 6px;
        color: var(--text-primary);
        font-size: 14px;
      }

      .callout p {
        margin: 0;
        font-size: 14px;
      }

      .script-link {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 8px 14px;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 12px;
        margin: 8px 0;
        color: var(--text-secondary);
        transition: all 0.2s;
      }

      .script-link:hover {
        background: var(--bg-code);
        border-color: var(--accent-dark);
        color: var(--accent-dark);
      }

      .script-link svg {
        width: 14px;
        height: 14px;
      }

      .flow-container {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 24px;
        margin: 24px 0;
      }

      .flow-step {
        display: flex;
        align-items: flex-start;
        gap: 14px;
        padding: 12px 0;
        border-bottom: 1px dashed var(--border-color);
      }

      .flow-step:last-child {
        border-bottom: none;
        padding-bottom: 0;
      }

      .flow-num {
        width: 28px;
        height: 28px;
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 13px;
        color: #fff;
        flex-shrink: 0;
      }

      .flow-content h4 {
        margin: 0 0 4px;
        font-size: 14px;
      }

      .flow-content p {
        margin: 0;
        font-size: 13px;
      }

      .flow-content code {
        font-size: 11px;
      }

      .resources-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
        margin: 20px 0;
      }

      .resource-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 16px;
        transition: all 0.2s;
      }

      .resource-card:hover {
        border-color: var(--accent-dark);
      }

      .resource-card h4 {
        margin: 0 0 4px;
        font-size: 14px;
        color: var(--text-primary);
      }

      .resource-card p {
        margin: 0;
        font-size: 12px;
        color: var(--text-muted);
      }

      .paths-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
        margin: 24px 0;
      }

      .path-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 16px;
      }

      .path-card h4 {
        margin: 0 0 8px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
      }

      .path-card p {
        font-size: 13px;
        margin: 0;
      }

      .path-badge {
        font-size: 10px;
        padding: 3px 6px;
        border-radius: 4px;
        font-family: 'JetBrains Mono', monospace;
        font-weight: 500;
      }

      .path-badge.classic {
        background: #dbeafe;
        color: #2563eb;
      }

      .path-badge.fast {
        background: #d1fae5;
        color: #059669;
      }

      .summary-list {
        list-style: none;
        padding: 0;
      }

      .summary-list li {
        padding: 6px 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .summary-list li::before {
        content: '‚úì';
        color: var(--accent-dark);
        font-weight: 600;
      }

      .closing {
        text-align: center;
        margin-top: 48px;
        padding-top: 32px;
        border-top: 1px solid var(--border-color);
      }

      .closing p {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 8px;
      }

      .closing .tagline {
        font-size: 28px;
        font-weight: 800;
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      @media (max-width: 640px) {
        body {
          padding: 40px 20px 60px;
          font-size: 14px;
        }
        .hero h1 {
          font-size: 28px;
        }
        .paths-grid {
          grid-template-columns: 1fr;
        }
        .resources-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header class="hero">
      <h1>Be <span>One of Us</span>.<br />Let's make Ethereum run real programs</h1>
      <p class="subtitle">
        Deploy and run WASM programs on Ethereum through Vara.eth. No L2, no new chains ‚Äî just Ethereum's security with
        parallel execution.
      </p>
    </header>

    <!-- Introduction -->
    <section id="intro">
      <h2>Introduction</h2>

      <p>
        In this guide, we'll dive into deploying and running actual WASM programs on Ethereum through Vara.eth. The idea
        is straightforward: write your program in Rust, compile it to WASM, and execute it in a high-performance
        parallel environment ‚Äî while keeping Ethereum as the settlement and security layer.
      </p>

      <p>
        <strong>No Layer 2, no new chains, no liquidity fragmentation, and no extra trust assumptions.</strong> Just
        Ethereum's security model and liquidity, with a compute layer that finally lets your app breathe.
      </p>

      <div class="callout callout-info">
        <div class="callout-title">Pre-confirmations</div>
        <p>
          Vara.eth brings a new execution feel to L1 apps: alongside canonical Ethereum finality, programs can return
          <strong>pre-confirmations</strong> ‚Äî fast, cryptographically backed acknowledgements from executors that
          arrive in near real time. Web2-like responsiveness with Ethereum-level settlement security.
        </p>
      </div>

      <h3>Resources</h3>
      <div class="resources-grid">
        <a href="https://gear-tech.io/gear-exe/whitepaper/vara.eth-one-pager.pdf" target="_blank" class="resource-card">
          <h4>üìÑ One-Pager</h4>
          <p>Quick overview of the Vara.eth approach</p>
        </a>
        <a href="https://gear-tech.io/gear-exe/whitepaper/gear-exe" target="_blank" class="resource-card">
          <h4>üìö Whitepaper</h4>
          <p>Full technical documentation</p>
        </a>
        <a href="https://github.com/gear-foundation/one-of-us" target="_blank" class="resource-card">
          <h4>üíª Example dApp</h4>
          <p>One of Us ‚Äî complete working example</p>
        </a>
        <a href="https://wiki.gear.foundation/" target="_blank" class="resource-card">
          <h4>üìñ Vara Wiki</h4>
          <p>Sails framework documentation</p>
        </a>
      </div>
    </section>

    <!-- Building -->
    <section id="building">
      <h2>Building the Program</h2>

      <p>
        Our running example is <strong>One of Us</strong> ‚Äî a small "fancy counter" that records Ethereum addresses of
        everyone who joins, prevents duplicates, and lets anyone query how many builders are in. It touches all the core
        patterns: persistent state, exported service methods, message-driven updates, and clean interface boundaries.
      </p>

      <p>
        The program is written in Rust using the <strong>Sails framework</strong>. A useful thing to note: this program
        is <strong>identical for Vara and Vara.eth</strong>. You don't write a separate "Ethereum version."
      </p>

      <a href="https://github.com/gear-foundation/one-of-us" target="_blank" class="script-link">
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"
          />
        </svg>
        gear-foundation/one-of-us
      </a>

      <h3>Prerequisites</h3>
      <p>
        Make sure your environment matches the standard Gear/Vara prerequisites: recent Rust toolchain, WASM build
        target, and basic system packages.
      </p>
      <p>
        See:
        <a href="https://wiki.gear.foundation/docs/getting-started-in-5-minutes" target="_blank"
          >Getting started in 5 minutes</a
        >
      </p>

      <h3>Build</h3>
      <pre data-lang="bash"><code>cargo build --release</code></pre>

      <p>After the build completes, your optimized WASM artifact will be in:</p>
      <pre data-lang="path"><code>target/wasm32-gear/release/*.opt.wasm</code></pre>

      <div class="callout callout-success">
        <div class="callout-title">‚úì Done</div>
        <p>
          You now have a Gear/Sails program compiled for Vara.eth. Next, we'll upload it to Ethereum for validation.
        </p>
      </div>

      <h3>Generate Solidity Interface (Optional)</h3>

      <p>
        If you want to interact with your Vara.eth program using Ethereum's native ABI encoding ‚Äî for example, calling
        it from other Solidity contracts or using standard Ethereum tooling ‚Äî you can generate a Solidity interface from
        your program's IDL.
      </p>

      <pre data-lang="bash"><code>cargo sails sol --idl-path ./target/wasm32-gear/release/one_of_us.idl</code></pre>

      <p>This generates an <code>OneOfUs.sol</code> file containing:</p>

      <ul>
        <li><strong>IOneOfUs</strong> ‚Äî interface with all your program's methods</li>
        <li><strong>OneOfUsAbi</strong> ‚Äî ABI contract for deployment</li>
        <li><strong>IOneOfUsCallbacks</strong> ‚Äî callback interface for receiving replies</li>
        <li><strong>OneOfUsCaller</strong> ‚Äî example contract showing how to call your program</li>
      </ul>

      <div class="callout callout-info">
        <div class="callout-title">‚Ñπ When do you need this?</div>
        <p>
          You only need the Solidity interface if you want to call your Vara.eth program from other smart contracts or
          prefer using Ethereum ABI tooling. For direct interaction via TypeScript/JavaScript, you can use the sails-js
          library with IDL instead.
        </p>
      </div>
    </section>

    <!-- Uploading -->
    <section id="uploading">
      <h2>Uploading Program Code</h2>

      <p>
        Now that you have an optimized WASM build, the next step is to get it onto Ethereum. First, it needs to be
        uploaded and validated through the vara-eth CLI. Think of this as the Ethereum-side "registration" of your WASM
        code.
      </p>

      <h3>Getting the CLI</h3>

      <h4>Option 1: Download from get.gear.rs</h4>
      <p>Get corresponding build from <a href="https://get.gear.rs/" target="_blank">get.gear.rs</a></p>

      <h4>Option 2: Build from source</h4>
      <pre data-lang="bash"><code><span class="comment"># Clone the gear repo, then build the CLI</span>
git clone https://github.com/gear-tech/gear.git
cargo build -p ethexe-cli -r</code></pre>

      <h3>Insert Your Key</h3>
      <pre
        data-lang="bash"
      ><code>./target/release/ethexe key insert <span class="string">$SENDER_PRIVATE_KEY</span></code></pre>

      <h3>Upload the WASM</h3>
      <pre data-lang="bash"><code>./target/release/ethexe --cfg none tx \
  --ethereum-rpc <span class="string">"https://hoodi-reth-rpc.gear-tech.io"</span> \
  --ethereum-router <span class="string">"0x579D6098197517140e5aec47c78d6f7181916dd6"</span> \
  --sender <span class="string">"$SENDER_ADDRESS"</span> \
  upload target/wasm32-gear/release/one_of_us.opt.wasm -w</code></pre>

      <div class="callout callout-warning">
        <div class="callout-title">‚ö† Get Test ETH</div>
        <p>
          Don't forget to get some test ETH on Hoodi to cover gas before you upload ‚Äî use
          <a href="https://www.hoodifaucet.io/" target="_blank">hoodifaucet.io</a>
        </p>
      </div>

      <h3>Result example</h3>
      <pre
        data-lang="output"
      ><code>Transaction: <span class="string">0xe5d6515879c6b1b3c0fe52981968e736595b5dedb0cecd2760966ed9c9030636</span>
Code ID: <span class="string">0x59810e0b451a041adff0fe2e551430186c664e2a97c80a80154003b74dd8829d</span></code></pre>
    </section>

    <!-- Program Creation -->
    <section id="creation">
      <h2>Program Creation</h2>

      <p>
        Uploading gives you a validated <code>codeId</code>, but there's still no running program yet. Program creation
        is the moment your WASM turns into an actual instance anchored on L1.
      </p>

      <p>
        Once you create it, Ethereum deploys a dedicated <strong>Mirror contract</strong> for your program. That Mirror
        becomes your on-chain gateway: the mailbox where you send messages, read the latest state hash, top up execution
        balance, and generally interact with the program.
      </p>

      <a
        href="https://github.com/gear-foundation/one-of-us/blob/master/deploy/create-program.ts"
        target="_blank"
        class="script-link"
      >
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"
          />
        </svg>
        View full script: create-program.ts
      </a>

      <pre
        data-lang="typescript"
      ><code><span class="keyword">import</span> { createPublicClient, createWalletClient, http, defineChain } <span class="keyword">from</span> <span class="string">'viem'</span>;
<span class="keyword">import</span> { privateKeyToAccount } <span class="keyword">from</span> <span class="string">'viem/accounts'</span>;
<span class="keyword">import</span> { EthereumClient } <span class="keyword">from</span> <span class="string">'@vara-eth/api'</span>;

<span class="keyword">const</span> hoodi = <span class="function">defineChain</span>({
  <span class="property">id</span>: <span class="number">560048</span>,
  <span class="property">name</span>: <span class="string">'Hoodi Testnet'</span>,
  <span class="property">network</span>: <span class="string">'hoodi'</span>,
  <span class="property">nativeCurrency</span>: { <span class="property">decimals</span>: <span class="number">18</span>, <span class="property">name</span>: <span class="string">'Ether'</span>, <span class="property">symbol</span>: <span class="string">'ETH'</span> },
  <span class="property">rpcUrls</span>: { <span class="property">default</span>: { <span class="property">http</span>: [ETH_RPC] } },
  <span class="property">testnet</span>: <span class="keyword">true</span>,
});

<span class="keyword">async function</span> <span class="function">main</span>() {
  <span class="keyword">const</span> account = <span class="function">privateKeyToAccount</span>(PRIVATE_KEY);
  
  <span class="keyword">const</span> publicClient = <span class="function">createPublicClient</span>({ <span class="property">chain</span>: hoodi, <span class="property">transport</span>: <span class="function">http</span>(ETH_RPC) });
  <span class="keyword">const</span> walletClient = <span class="function">createWalletClient</span>({ account, <span class="property">chain</span>: hoodi, <span class="property">transport</span>: <span class="function">http</span>(ETH_RPC) });

  <span class="comment">// Setup Vara.eth client</span>
  <span class="keyword">const</span> ethereumClient = <span class="keyword">new</span> <span class="type">EthereumClient</span>(publicClient, walletClient, ROUTER_ADDRESS);
  <span class="keyword">await</span> ethereumClient.isInitialized;
  <span class="keyword">const</span> router = ethereumClient.router;

  <span class="comment">// Create program instance</span>
  <span class="keyword">const</span> tx = <span class="keyword">await</span> router.<span class="function">createProgram</span>(CODE_ID);
  <span class="keyword">const</span> receipt = <span class="keyword">await</span> tx.<span class="function">sendAndWaitForReceipt</span>();

  <span class="comment">// Get the program ID (Mirror address)</span>
  <span class="keyword">const</span> programId = <span class="keyword">await</span> tx.<span class="function">getProgramId</span>();
  console.<span class="function">log</span>(<span class="string">'Program ID:'</span>, programId);
}</code></pre>

      <h3>Option 2: Create Program with Solidity ABI Interface</h3>

      <p>
        If you want to interact with your Vara.eth program using a familiar Solidity ABI (for example, from other smart
        contracts or Ethereum tooling), you can create the program with an ABI interface. This requires deploying a
        Solidity contract that defines the interface, then linking it during program creation.
      </p>

      <p>First, generate the Solidity interface from your program's IDL:</p>

      <pre data-lang="bash"><code>cargo sails sol --idl-path ./target/wasm32-gear/release/your_program.idl</code></pre>

      <p>
        This generates a <code>.sol</code> file with the interface, ABI contract, and callback definitions. Deploy the
        ABI contract and use its address when creating the program:
      </p>

      <a
        href="https://github.com/gear-foundation/one-of-us/blob/master/deploy/create-program-abi.ts"
        target="_blank"
        class="script-link"
      >
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"
          />
        </svg>
        View full script: create-program-abi.ts
      </a>

      <pre
        data-lang="typescript"
      ><code><span class="keyword">import</span> { EthereumClient } <span class="keyword">from</span> <span class="string">'@vara-eth/api'</span>;
<span class="keyword">import</span> { oneOfUsAbi, oneOfUsBytecode } <span class="keyword">from</span> <span class="string">'./OneOfUsAbi'</span>;

<span class="keyword">async function</span> <span class="function">main</span>() {
  <span class="comment">// ... setup clients ...</span>
  <span class="keyword">const</span> ethereumClient = <span class="keyword">new</span> <span class="type">EthereumClient</span>(publicClient, walletClient, ROUTER_ADDRESS);
  <span class="keyword">await</span> ethereumClient.isInitialized;
  <span class="keyword">const</span> router = ethereumClient.router;

  <span class="comment">// Step 1: Deploy Solidity ABI contract</span>
  <span class="keyword">const</span> deployHash = <span class="keyword">await</span> walletClient.<span class="function">deployContract</span>({
    <span class="property">abi</span>: oneOfUsAbi,
    <span class="property">bytecode</span>: oneOfUsBytecode,
    account,
  });

  <span class="keyword">const</span> deployReceipt = <span class="keyword">await</span> publicClient.<span class="function">waitForTransactionReceipt</span>({ <span class="property">hash</span>: deployHash });
  <span class="keyword">const</span> abiAddress = deployReceipt.contractAddress;
  console.<span class="function">log</span>(<span class="string">'ABI Contract deployed:'</span>, abiAddress);

  <span class="comment">// Step 2: Create program with ABI interface</span>
  <span class="keyword">const</span> tx = <span class="keyword">await</span> router.<span class="function">createProgramWithAbiInterface</span>(CODE_ID, abiAddress);
  <span class="keyword">const</span> receipt = <span class="keyword">await</span> tx.<span class="function">sendAndWaitForReceipt</span>();

  <span class="keyword">const</span> programId = <span class="keyword">await</span> tx.<span class="function">getProgramId</span>();
  console.<span class="function">log</span>(<span class="string">'Program ID:'</span>, programId);
}</code></pre>

      <p>
        With the ABI interface, you can interact with your Vara.eth program using standard Ethereum tools, Solidity
        contracts, or any library that supports contract ABIs.
      </p>
    </section>

    <!-- Top-Up -->
    <section id="topup">
      <h2>Top-Up Program Balance</h2>

      <p>
        Before your program can execute anything, it needs fuel. Vara.eth doesn't charge users for computation directly
        ‚Äî instead, every program has an internal <strong>Executable Balance</strong> funded in wVARA. When messages
        arrive, executors spend from that balance to run your WASM. If the balance is low, the system won't "break";
        messages simply wait in the queue until the program is topped up again. That's the core of the
        <strong>reverse-gas model</strong>: developers fund execution, users just sign and use the app.
      </p>

      <p>
        Practically, topping up is a two-step Ethereum flow. First you approve your program (or its Mirror) to spend
        wVARA from your wallet, then you call the Mirror's top-up method to move wVARA into the program's executable
        balance. The Mirror records the top-up on Ethereum and signals executors that the program is funded.
      </p>

      <a href="https://idea.gear-tech.io/balance" target="_blank" class="script-link">
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1.41 16.09V20h-2.67v-1.93c-1.71-.36-3.16-1.46-3.27-3.4h1.96c.1 1.05.82 1.87 2.65 1.87 1.96 0 2.4-.98 2.4-1.59 0-.83-.44-1.61-2.67-2.14-2.48-.6-4.18-1.62-4.18-3.67 0-1.72 1.39-2.84 3.11-3.21V4h2.67v1.95c1.86.45 2.79 1.86 2.85 3.39H14.3c-.05-1.11-.64-1.87-2.22-1.87-1.5 0-2.4.68-2.4 1.64 0 .84.65 1.39 2.67 1.91s4.18 1.39 4.18 3.91c-.01 1.83-1.38 2.83-3.12 3.16z"
          />
        </svg>
        Get your wVARA
      </a>

      <a
        href="https://github.com/gear-foundation/one-of-us/blob/master/deploy/fund-program.ts"
        target="_blank"
        class="script-link"
      >
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"
          />
        </svg>
        View full script: fund-program.ts
      </a>

      <pre
        data-lang="typescript"
      ><code><span class="keyword">import</span> { EthereumClient, getMirrorClient } <span class="keyword">from</span> <span class="string">'@vara-eth/api'</span>;

<span class="keyword">async function</span> <span class="function">main</span>() {
  <span class="keyword">const</span> ethereumClient = <span class="keyword">new</span> <span class="type">EthereumClient</span>(publicClient, walletClient, ROUTER_ADDRESS);
  <span class="keyword">await</span> ethereumClient.isInitialized;
  <span class="keyword">const</span> wvara = ethereumClient.wvara;
  <span class="keyword">const</span> mirror = <span class="function">getMirrorClient</span>(PROGRAM_ID, ethereumClient);

  <span class="keyword">const</span> amount = <span class="function">BigInt</span>(<span class="number">10_000_000_000_000</span>); <span class="comment">// 10 wVARA</span>

  <span class="comment">// Step 1: Approve wVARA for the program to spend</span>
  <span class="keyword">const</span> approveTx = <span class="keyword">await</span> wvara.<span class="function">approve</span>(PROGRAM_ID, amount);
  <span class="keyword">await</span> approveTx.<span class="function">sendAndWaitForReceipt</span>();

  <span class="comment">// Step 2: Top up executable balance via Mirror</span>
  <span class="keyword">const</span> topUpTx = <span class="keyword">await</span> mirror.<span class="function">executableBalanceTopUp</span>(amount);
  <span class="keyword">await</span> topUpTx.<span class="function">sendAndWaitForReceipt</span>();
}</code></pre>
    </section>

    <!-- Interaction -->
    <section id="interaction">
      <h2>Program Interaction</h2>

      <p>
        Once your program is created and funded, you can start talking to it. In Vara.eth there are
        <strong>two interaction paths</strong>:
      </p>

      <div class="paths-grid">
        <div class="path-card">
          <h4><span class="path-badge classic">L1</span> Classic Transaction</h4>
          <p>
            Send messages as normal Ethereum transactions to the program's Mirror contract, then wait for execution and
            final settlement on L1.
          </p>
        </div>
        <div class="path-card">
          <h4><span class="path-badge fast">FAST</span> Pre-confirmed (Injected)</h4>
          <p>Off-chain pre-confirmation with eventual Ethereum settlement. Web2-like speed, L1 finality.</p>
        </div>
      </div>

      <h3>Classic Transaction (via Mirror)</h3>
      <p>This is the normal Ethereum flow. You still use Sails ABI/IDL so you never touch raw bytes by hand.</p>

      <div class="callout callout-info">
        <div class="callout-title">üí° Quick Testing via Etherscan</div>
        <p>
          If your program's Mirror contract is verified with ABI, you can also interact with it directly through
          Etherscan. Go to the Mirror address on Hoodi Etherscan, open the <strong>Write Contract</strong> tab, connect
          your wallet, and call <code>sendMessage</code> with your encoded payload. Great for quick tests without
          writing code.
        </p>
      </div>

      <a
        href="https://github.com/gear-foundation/one-of-us/blob/master/deploy/classic-tx.ts"
        target="_blank"
        class="script-link"
      >
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"
          />
        </svg>
        View full script: classic-tx.ts
      </a>

      <pre
        data-lang="typescript"
      ><code><span class="keyword">import</span> { EthereumClient, getMirrorClient } <span class="keyword">from</span> <span class="string">'@vara-eth/api'</span>;
<span class="keyword">import</span> { Sails } <span class="keyword">from</span> <span class="string">'sails-js'</span>;
<span class="keyword">import</span> { SailsIdlParser } <span class="keyword">from</span> <span class="string">'sails-js-parser'</span>;

<span class="keyword">async function</span> <span class="function">main</span>() {
  <span class="keyword">const</span> ethereumClient = <span class="keyword">new</span> <span class="type">EthereumClient</span>(publicClient, walletClient, ROUTER_ADDRESS);
  <span class="keyword">await</span> ethereumClient.isInitialized;
  <span class="keyword">const</span> mirror = <span class="function">getMirrorClient</span>(PROGRAM_ID, ethereumClient);

  <span class="comment">// Initialize Sails from your program IDL</span>
  <span class="keyword">const</span> parser = <span class="keyword">await</span> SailsIdlParser.<span class="function">new</span>();
  <span class="keyword">const</span> sails = <span class="keyword">new</span> <span class="type">Sails</span>(parser);
  sails.<span class="function">parseIdl</span>(<span class="function">readFileSync</span>(<span class="string">'./one_of_us.idl'</span>, <span class="string">'utf-8'</span>));

  <span class="comment">// Encode a regular call using ABI/IDL</span>
  <span class="keyword">const</span> payload = sails.services.OneOfUs.functions.JoinUs.<span class="function">encodePayload</span>();

  <span class="comment">// Send through Ethereum to Mirror</span>
  <span class="keyword">const</span> tx = <span class="keyword">await</span> mirror.<span class="function">sendMessage</span>(payload, <span class="number">0n</span>);
  <span class="keyword">const</span> receipt = <span class="keyword">await</span> tx.<span class="function">sendAndWaitForReceipt</span>();

  <span class="comment">// Wait for the program reply</span>
  <span class="keyword">const</span> { waitForReply } = <span class="keyword">await</span> tx.<span class="function">setupReplyListener</span>();
  <span class="keyword">const</span> { <span class="property">payload</span>: replyPayload } = <span class="keyword">await</span> waitForReply;

  <span class="comment">// Decode result</span>
  <span class="keyword">const</span> result = sails.services.OneOfUs.functions.JoinUs.<span class="function">decodeResult</span>(replyPayload);
}</code></pre>

      <h3>Pre-confirmed Transaction (Injected)</h3>

      <p>
        This is what makes Vara.eth feel different in practice:
        <strong>off-chain pre-confirmation with eventual Ethereum settlement</strong>.
      </p>

      <p>
        Instead of waiting for an L1 transaction to be mined, you submit your message directly to the executor network.
        Executors run the WASM program immediately, return a cryptographically backed pre-confirmation in near real
        time, and then the same result is later anchored on Ethereum.
      </p>

      <div class="callout callout-success">
        <div class="callout-title">‚úì Zero Gas for Users</div>
        <p>
          Your users don't even have to pay for this interaction. Execution is funded from the program's internal wVARA
          balance ‚Äî not from the user's pocket. The user just signs in MetaMask, gets an instant pre-confirmation, and
          moves on.
        </p>
      </div>

      <a
        href="https://github.com/gear-foundation/one-of-us/blob/master/deploy/test-injected.ts"
        target="_blank"
        class="script-link"
      >
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"
          />
        </svg>
        View full script: test-injected.ts
      </a>

      <a href="https://github.com/gear-tech/gear-js/tree/main/apis/vara-eth" target="_blank" class="script-link">
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"
          />
        </svg>
        Full @vara-eth/api documentation
      </a>

      <pre data-lang="typescript"><code><span class="keyword">import</span> { EthereumClient, VaraEthApi, WsVaraEthProvider } <span class="keyword">from</span> <span class="string">'@vara-eth/api'</span>;

<span class="keyword">async function</span> <span class="function">main</span>() {
  <span class="keyword">const</span> ethereumClient = <span class="keyword">new</span> <span class="type">EthereumClient</span>(publicClient, walletClient, ROUTER_ADDRESS);
  <span class="keyword">await</span> ethereumClient.isInitialized;

  <span class="comment">// Connect to Vara.eth network via WebSocket</span>
  <span class="keyword">const</span> api = <span class="keyword">new</span> <span class="type">VaraEthApi</span>(
    <span class="keyword">new</span> <span class="type">WsVaraEthProvider</span>(VARA_ETH_WS),
    ethereumClient
  );

  <span class="comment">// Encode the call</span>
  <span class="keyword">const</span> payload = sails.services.OneOfUs.functions.JoinUs.<span class="function">encodePayload</span>();

  <span class="comment">// Build an injected tx (off-chain pre-confirmation path)</span>
  <span class="keyword">const</span> injected = <span class="keyword">await</span> api.<span class="function">createInjectedTransaction</span>({
    <span class="property">destination</span>: PROGRAM_ID,
    <span class="property">payload</span>: payload,
    <span class="property">value</span>: <span class="number">0n</span>,
  });

  <span class="comment">// Wait for full transaction promise (includes reply)</span>
  <span class="keyword">const</span> result = <span class="keyword">await</span> injected.<span class="function">sendAndWaitForPromise</span>();
  <span class="comment">// Result contains 'Accept' or 'Reject' status with reply payload</span>
}</code></pre>
    </section>

    <!-- Read State -->
    <section id="state">
      <h2>Read State</h2>

      <p>
        Once you've sent your first messages, the next thing you'll want is a reliable way to check what the program
        looks like "right now."
      </p>

      <p>
        The canonical program state is anchored on Ethereum as a <strong>state hash</strong> in the Mirror contract,
        while the full state lives on the Vara.eth side and can be fetched by that hash.
      </p>

      <div class="callout callout-info">
        <div class="callout-title">‚è± When Can You Read the New State?</div>
        <p>
          <strong>Classic L1 transaction:</strong> You can only read the updated state after the transaction is
          finalized on Ethereum. Until then, you're still seeing the previous state.
        </p>
        <p style="margin-top: 8px">
          <strong>Injected transaction:</strong> There are two moments to consider. Calling <code>send()</code> returns
          <code>Accept</code> or <code>Reject</code> immediately ‚Äî this is a guarantee that the validator has accepted
          the transaction and will execute it, but the state hasn't changed yet. If you use
          <code>sendAndWaitForPromise()</code>, you wait for the actual execution result (reply). Once you receive that
          reply, the state is updated and you can read it immediately.
        </p>
        <p style="margin-top: 8px">
          <strong>Optimistic UI:</strong> If your app knows the computational result in advance (e.g., incrementing a
          counter), you can update the UI right after receiving <code>Accept</code> ‚Äî you have a guarantee the
          transaction will be included.
        </p>
      </div>

      <a
        href="https://github.com/gear-foundation/one-of-us/blob/master/deploy/read-state.ts"
        target="_blank"
        class="script-link"
      >
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"
          />
        </svg>
        View full script: read-state.ts
      </a>

      <pre
        data-lang="typescript"
      ><code><span class="keyword">import</span> { EthereumClient, VaraEthApi, WsVaraEthProvider, getMirrorClient } <span class="keyword">from</span> <span class="string">'@vara-eth/api'</span>;

<span class="keyword">async function</span> <span class="function">main</span>() {
  <span class="keyword">const</span> ethereumClient = <span class="keyword">new</span> <span class="type">EthereumClient</span>(publicClient, walletClient, ROUTER_ADDRESS);
  <span class="keyword">await</span> ethereumClient.isInitialized;
  <span class="keyword">const</span> mirror = <span class="function">getMirrorClient</span>(PROGRAM_ID, ethereumClient);

  <span class="comment">// Connect to Vara.eth API</span>
  <span class="keyword">const</span> api = <span class="keyword">new</span> <span class="type">VaraEthApi</span>(
    <span class="keyword">new</span> <span class="type">WsVaraEthProvider</span>(VARA_ETH_WS),
    ethereumClient
  );

  <span class="comment">// Get the current state hash from Ethereum (Mirror contract)</span>
  <span class="keyword">const</span> stateHash = <span class="keyword">await</span> mirror.<span class="function">stateHash</span>();

  <span class="comment">// Query: How many builders joined?</span>
  <span class="keyword">const</span> countPayload = sails.services.OneOfUs.queries.Count.<span class="function">encodePayload</span>();
  
  <span class="keyword">const</span> countReply = <span class="keyword">await</span> api.call.program.<span class="function">calculateReplyForHandle</span>(
    account.address,
    PROGRAM_ID,
    countPayload
  );

  <span class="keyword">const</span> count = sails.services.OneOfUs.queries.Count.<span class="function">decodeResult</span>(countReply.payload);
  console.<span class="function">log</span>(<span class="string">'Builders count:'</span>, count);

  <span class="comment">// Query: Who are the builders?</span>
  <span class="keyword">const</span> buildersPayload = sails.services.OneOfUs.queries.Builders.<span class="function">encodePayload</span>();
  
  <span class="keyword">const</span> buildersReply = <span class="keyword">await</span> api.call.program.<span class="function">calculateReplyForHandle</span>(
    account.address,
    PROGRAM_ID,
    buildersPayload
  );

  <span class="keyword">const</span> builders = sails.services.OneOfUs.queries.Builders.<span class="function">decodeResult</span>(buildersReply.payload);
  console.<span class="function">log</span>(<span class="string">'Builders list:'</span>, builders);
}</code></pre>

      <h4>Understanding State Types</h4>
      <p>
        <strong>Business Logic State via Execution:</strong> When you need to execute program logic and get computed
        results, use <code>calculateReplyForHandle</code>. This actually runs your query through the WASM program.
      </p>
      <p>
        <strong>Program Metadata and Storage State:</strong> For system-level information and raw program state, use
        <code>readState</code>. This returns infrastructure-level data about the program's storage, balance, and system
        state.
      </p>
    </section>

    <!-- Complete Flow -->
    <section id="flow">
      <h2>Complete Flow</h2>

      <div class="flow-container">
        <div class="flow-step">
          <div class="flow-num">1</div>
          <div class="flow-content">
            <h4>Build your Rust program with Sails</h4>
            <p><code>cargo build --release</code></p>
          </div>
        </div>
        <div class="flow-step">
          <div class="flow-num">2</div>
          <div class="flow-content">
            <h4>Upload WASM via CLI</h4>
            <p><code>ethexe upload program.opt.wasm</code> ‚Üí Get <code>CODE_ID</code></p>
          </div>
        </div>
        <div class="flow-step">
          <div class="flow-num">3</div>
          <div class="flow-content">
            <h4>Create program instance</h4>
            <p><code>router.createProgram(CODE_ID)</code> ‚Üí Get <code>PROGRAM_ID</code> (Mirror address)</p>
          </div>
        </div>
        <div class="flow-step">
          <div class="flow-num">4</div>
          <div class="flow-content">
            <h4>Fund the program</h4>
            <p><code>wvara.approve()</code> + <code>mirror.executableBalanceTopUp()</code></p>
          </div>
        </div>
        <div class="flow-step">
          <div class="flow-num">5</div>
          <div class="flow-content">
            <h4>Interact with your program</h4>
            <p>
              <strong>Classic:</strong> <code>mirror.sendMessage()</code> ‚Äî Full L1 finality<br />
              <strong>Injected:</strong> <code>api.createInjectedTransaction()</code> ‚Äî Instant pre-confirmation
            </p>
          </div>
        </div>
        <div class="flow-step">
          <div class="flow-num">6</div>
          <div class="flow-content">
            <h4>Read state</h4>
            <p><code>api.call.program.calculateReplyForHandle()</code></p>
          </div>
        </div>
      </div>

      <h3>Summary</h3>
      <ul class="summary-list">
        <li>Build a Gear program with Sails</li>
        <li>Upload and validate WASM on Ethereum</li>
        <li>Create a program instance (Mirror contract)</li>
        <li>Fund the program with wVARA (reverse-gas model)</li>
        <li>Send messages via classic Ethereum transactions</li>
        <li>Send injected transactions for instant pre-confirmations</li>
        <li>Read program state from Vara.eth</li>
      </ul>

      <p>
        The key takeaway: Vara.eth gives you <strong>Ethereum's security and liquidity</strong> with
        <strong>parallel WASM execution and Web2-like speed</strong>. Your users interact through MetaMask like any
        other Ethereum app, but under the hood, they're getting instant feedback from a high-performance compute layer.
      </p>

      <div class="closing">
        <p>Welcome to Vara.eth.</p>
        <div class="tagline">Be one of us.</div>
      </div>
    </section>
  </body>
</html>
